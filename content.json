{"pages":[{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"使用proxy代理解决vue跨域","text":"方法： 使用vue-cli构建工具构建的vue项目中，在config/index.js中的proxyTable中添加 ：1234567891011&apos;/api&apos;: { target:&apos;http://localhost:8080&apos;, // 这里的地址写自己要请求的地址，而不是数据接口的地址 changeOrigin:true, // 在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题 pathRewrite:{ // 路径重写， &apos;^/api&apos;: &apos;&apos; // 替换target中的请求地址，也就是说以后你在请求http://api.douban.com/v2/XXXXX这个地址的时候直接写成/api即可。 } }``` 并且在main.js中添加 axios.defaults.baseURL=&quot;/api&quot;;这样就解决跨域问题了，然后在你的vue页面请求数据时，就直接按原来的方式照写就行了。是不是很简单 requestData () { this.$axios.get(‘http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page=1') .then( (res) =&gt; { console.log(res.data) this.lists = res.data.result } ) } `","link":"/2020/04/19/使用proxy代理解决vue跨域/"},{"title":"简单的数据请求，利用jquery做的，解决了跨域问题","text":"这里就是简单的记录一下利用jquery请求数据的方法，这样能完美的解决跨域问题，简直太好了，页面什么的不用在意，就是随便拿了一个页面用，主要是看数据。 style:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172.sma_container { width: 380px; padding: 5px; margin: 5px auto; } .top { display: flex; justify-content: flex-start; } .top h3 { margin-left: 130px; font-weight: 50 } .top svg { transform: translateY(22px); cursor: pointer; } .down .ph_user, .ph_pwd { border-bottom: 1px solid rgb(175, 175, 175); width: 85%; margin: 5px auto; padding: 10px 15px; } .ph_user input { width: 100%; border: 0; outline: none; font-size: 16px; } .ph_pwd input { width: 70%; outline: none; border: 0; font-size: 16px; } .ph_pwd span { display: inline-block; width: 70px; padding: 10px 10px; background: red; font-size: 14px; border-radius: 5px; color: white; cursor: pointer; } .down .btn { width: 90%; padding: 10px 0; margin: 15px auto; background: red; border-radius: 5px; text-align: center; cursor: pointer; } .down .btn button { color: white; font-size: 18px; border: 0; outline: none; background: transparent; } html:12345678910111213141516171819202122&lt;div class=\"sma_container\"&gt; &lt;div class=\"top\"&gt; &lt;svg t=\"1568950194228\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"1992\" width=\"20\" height=\"20\"&gt; &lt;path d=\"M913.92 145.92l-35.84-35.84L512 475.52 145.92 110.08l-35.84 35.84L475.52 512l-365.44 366.08 35.84 35.84L512 548.48l366.08 365.44 35.84-35.84L548.48 512z\" p-id=\"1993\"&gt;&lt;/path&gt; &lt;/svg&gt; &lt;h3&gt;绑定手机号&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"down\" style=\"margin-top:25px\"&gt; &lt;div class=\"ph_user\"&gt; &lt;input type=\"phone\" placeholder=\"请输入您的手机号\" /&gt; &lt;/div&gt; &lt;div class=\"ph_pwd\" style=\"margin-top:15px\"&gt; &lt;input type=\"text\" placeholder=\"请输入验证码\" /&gt; &lt;span&gt;发送验证码&lt;/span&gt; &lt;/div&gt; &lt;div class=\"btn\"&gt; &lt;button&gt;登录&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; javascript: 123456789101112131415//这里是利用jquer请求数据，已经解决了跨域问题 $(\".btn\").click(function () { $.ajax({ type: \"get\", url: \"https://api.asilu.com/cloud-music/163/\", data: \"\", dataType: \"jsonp\", crossDomain: true, jsonpCallback: \"jsonpCallbackFun\", jsonp: \"callback\", success: function (data) { console.log(data) }, }); });","link":"/2019/09/26/简单的利用jquery做数据请求-解决了跨域问题/"},{"title":"一个简单的jquery轮播图","text":"Html：1234567891011121314151617181920&lt;div class=\"slideBox\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"image/Lslide3.jpg\" alt=\"\" width=\"300\" height=\"480\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"image/Lslide4.jpg\" alt=\"\" width=\"300\" height=\"480\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"image/Lslide5.jpg\" alt=\"\" width=\"300\" height=\"480\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"image/Lslide6.jpg\" alt=\"\" width=\"300\" height=\"480\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"image/Lslide2.jpg\" alt=\"\" width=\"300\" height=\"480\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"image/Lslide1.jpg\" alt=\"\" width=\"300\" height=\"480\"/&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"spanBox\"&gt; &lt;span class=\"active\"&gt;q&lt;/span&gt; &lt;span&gt;a&lt;/span&gt; &lt;span&gt;z&lt;/span&gt; &lt;span&gt;w&lt;/span&gt; &lt;span&gt;s&lt;/span&gt; &lt;span&gt;x&lt;/span&gt; &lt;/div&gt; &lt;div class=\"prev\"&gt;&lt;img src=\"image/left_arrow.jpg\" width=\"15\" height=\"50\" alt=\"\"/&gt;&lt;/div&gt; &lt;div class=\"next\"&gt;&lt;img src=\"image/right_arrow.jpg\" width=\"15\" height=\"50\" alt=\"\"/&gt;&lt;/div&gt;&lt;/div&gt; 上面是html代码，代码的结构比较简单，ul标签是要左右移动的，所以怎么设置position属性？，然后span标签是提供索引和下标控制符，绑定动画的。prev和next类名的div标签是提供左右按钮。 CSS:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869*{ padding:0px; border:0px; margin:0px;}ul { list-style:none;}.slideBox { margin:50px auto; width:300px; height:480px; box-shadow:2px 2px 10px #C38DD4; border-radius:20px; position:relative; overflow:hidden;}.slideBox ul { position:relative; width:2000px;}.slideBox ul li { float:left; width:300px; height:480px; position:relative; }.spanBox { position:absolute; width:300px; height:20px; bottom:10px; left:80px;}.spanBox span { width:18px; height:18px; margin-left:5px; background-color:rgba(201,178,207,1.00); float:left; line-height:16px; text-align:center; text-shadow:2px 2px 2px #C5EBF0; font-family:cabin-sketch; font-size:15px;}.slideBox .spanBox .active { background-color:rgba(155,83,244,0.79); border:solid 1px #BEEBEC; border-radius:4px;}.prev { position:absolute; left:0px; top:320px; float:left; border-left:solid 1px rgba(251,245,246,1.00); opacity:0.5;}.next { width:15px; height:50px; position:absolute; right:0px; top:320px; float:right; border-right:solid 1px rgba(245,237,237,1.00); opacity:0.5} Jquery:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950$(document).ready(function(){ var slideBox = $(\".slideBox\"); var ul = slideBox.find(\"ul\"); var oneWidth = slideBox.find(\"ul li\").eq(0).width(); var number = slideBox.find(\".spanBox span\");//注意分号 和逗号的用法 var timer = null; var sw = 0; //每个span绑定click事件，完成切换颜色和动画，以及读取参数值 number.on(\"click\",function (){ $(this).addClass(\"active\").siblings(\"span\").removeClass(\"active\"); sw=$(this).index(); ul.animate({ \"right\":oneWidth*sw,//ul标签的动画为向左移动； }); }); //左右按钮的控制效果 $(\".next\").stop(true,true).click(function (){ sw++; if(sw==number.length){sw=0}; number.eq(sw).trigger(\"click\"); }); $(\".prev\").stop(true,true).click(function (){ sw--; if(sw==number.length){sw=0}; number.eq(sw).trigger(\"click\"); }); //定时器的使用，自动开始 timer = setInterval(function (){ sw++; if(sw==number.length){sw=0}; number.eq(sw).trigger(\"click\"); },2000); //hover事件完成悬停和，左右图标的动画效果 slideBox.hover(function(){ $(\".next,.prev\").animate({ \"opacity\":1, },200); clearInterval(timer); },function(){ $(\".next,.prev\").animate({ \"opacity\":0.5, },500); timer = setInterval(function (){ sw++; if(sw==number.length){sw=0}; number.eq(sw).trigger(\"click\"); },2000); }) })","link":"/2019/05/22/一个简单的Jquery轮播图/"},{"title":"Vue 面试题，内含详细讲解","text":"1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。优点：用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；基于上面一点，SPA 相对对服务器压力小；前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；缺点：初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。 2、v-show 与 v-if 有什么区别？v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。 3、Class 与 Style 如何动态绑定？Class 可以通过对象语法和数组语法进行动态绑定：对象语法：123456&lt;div v-bind:class=&quot;{ active: isActive, &apos;text-danger&apos;: hasError }&quot;&gt;&lt;/div&gt;data: { isActive: true, hasError: false} 数组语法：123456&lt;div v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;&lt;/div&gt;data: { activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos;} Style 也可以通过对象语法和数组语法进行动态绑定：对象语法：123456&lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize + &apos;px&apos; }&quot;&gt;&lt;/div&gt;data: { activeColor: &apos;red&apos;, fontSize: 30} 数组语法：12345678910&lt;div v-bind:style=&quot;[styleColor, styleSize]&quot;&gt;&lt;/div&gt;data: { styleColor: { color: &apos;red&apos; }, styleSize:{ fontSize:&apos;23px&apos; }} 4、怎样理解 Vue 的单向数据流？所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定 ：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。有两种常见的试图改变一个 prop 的情形 :这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：123456props: [&apos;initialCounter&apos;],data: function () { return { counter: this.initialCounter }} 这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性123456props: [&apos;size&apos;],computed: { normalizedSize: function () { return this.size.trim().toLowerCase() }} 5、computed 和 watch 的区别和运用的场景？computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；运用场景：当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 6、直接给一个数组项赋值，Vue 能检测到变化吗？由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue当你修改数组的长度时，例如：vm.items.length = newLength为了解决第一个问题，Vue 提供了以下操作方法：123456// Vue.setVue.set(vm.items, indexOfItem, newValue)// vm.$set，Vue.set的一个别名vm.$set(vm.items, indexOfItem, newValue)// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue) 为了解决第二个问题，Vue 提供了以下操作方法：12// Array.prototype.splicevm.items.splice(newLength) 7、谈谈你对 Vue 生命周期的理解？（1）生命周期是什么？Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。 （2）各个生命周期的作用","link":"/2019/07/22/Vue 面试题，内含详细讲解/"},{"title":"谢宇莲的个人简历","text":"谢宇莲性 别：女联系方式：18437979252邮 箱：13208295650@163.com现居地址：四川成都出生年月：1995.12年 龄：24岁工作年限：2年 专业技能： 熟悉W3C标准和Web语义化，能熟练运用HTML5，CSS3及其新特性编写兼容主流浏览器的页面布局；2.能适当运用CSS3使页面在现代浏览器上效果更佳； 熟练运用rem单位和flex布局实现不同浏览器宽度下的整页缩放；4.熟练使用photoshop软件进行简单的图片处理，能根据图片特征保存成最优的格式；5.熟练使用原生javaScript以及常用javaScript库，如jQuery； 能运用模块化、面向对象的方式编程；7.了解http协议，能够根据http请求报文、响应报文和状态码排查问题；8.熟练运用ajax实现异步数据传递，熟悉JSON等数据交换格式； 了解如何使用node.js搭建本地server模拟接口返回数据测试ajax接口；10.能使用Bootstrap、Vue等前端样式库和框架进行开发，能够熟练运用JQuery，Bootstrap(栅格系统的响应式网页)。 工作经历：2017.5-至今 洛阳市儒墨科技有限公司 WEB前端开发工程师2017年开始实习，实习岗位是研发助理，主要负责协助研发部门进行平台开发，具体负责平台数据配置，数据库存储过程编写以及平时的数据库管理与优化。2018年年初转正为研发专员，日常工作是对公司的大数据平台进行维护，定时清理数据以及备份，以及数据接口的测试。前端方面工作主要包括：1.负责公司产品或项目WEB前端开发；2.根据产品需求和UI效果利用VScode编程软件进行标准网页制作；3.负责JS逻辑设计与开发，JQuery特效编写以及使用插件实现特效；4.解决主流浏览器兼容性问题，对网站用户体验性能进行优化；5.完成产品前端展示鲜果和交互功能；6.负责代码的功能测试以及反馈，按照项目经理要求完成好每一项工作。 教育背景：2014.9-2018.6 洛阳师范学院 本科(二本) 技能证书：大学英语四/六级(CET-4/6) 机动车驾驶证 计算机二级证书管理学学位证 互联网项目创新创业大赛校级一等奖 HTML5前端开发工程师Web全栈研发工程师 企业级Web应用研发工程师 JS开发工程师Web应用架构工程师 混合APP高级开发工程师 移动端Web开发工程师前端Web技术工程师 服务端运维工程师 高级运维工程师 自我评价:1.对前端技术具有浓厚的兴趣，喜欢逛CSDN，博客园等技术论坛；2.具备良好的审美能力，有良好的代码编程习惯；3.学习适应能力强，愿意不断学习新知识丰富自己；4.抗压能力强，有信心在不同的工作强度下进行开发工作；5.性格随和，具有良好的团队合作精神。","link":"/2019/09/06/谢宇莲的个人简历/"},{"title":"Vue 面试题，内含详细讲解","text":"","link":"/2020/02/28/闭包/"},{"title":"Vue 面试题，内含详细讲解","text":"一、关于继承的几种方式，包含6种1.原型链继承2.借用构造函数继承3.组合继承4.原型式继承5.寄生式继承6.寄生组合式继承 二、继承的使用场景","link":"/2020/02/28/关于继承的几种方式/"},{"title":"常用功能（一），购物车功能（jquery,实现单选，全选，小计，总计，删除）","text":"以下是一个简单的购物车功能的demo，在接下来的博客里，我会陆续写到我们经常会用到的各种功能哟！HTML:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;!-- 利用table标签简单创建样式 --&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt; &lt;input class=\"all_ck\" type=\"checkbox\"&gt;全选&lt;/th&gt; &lt;th&gt;商品&lt;/th&gt; &lt;th&gt;单价&lt;/th&gt; &lt;th&gt;数量&lt;/th&gt; &lt;th&gt;小计&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class=\"td_d\"&gt; &lt;input class=\"ck_box\" type=\"checkbox\"&gt; &lt;/td&gt; &lt;td class=\"goods\"&gt; &lt;img src=\"img/2.jpg\" align=\"left\"&gt; &lt;span&gt;三只松鼠-碧根果210g&lt;/span&gt; &lt;/td&gt; &lt;td class=\"td_d price\"&gt;￥38.90&lt;/td&gt; &lt;td class=\"td_d\"&gt; &lt;button class=\"minus\"&gt;-&lt;/button&gt; &lt;input class=\"num\" value=\"1\" type=\"text\"&gt; &lt;button class=\"add\"&gt;+&lt;/button&gt; &lt;/td&gt; &lt;td class=\"td_d smallprice\"&gt;￥38.90&lt;/td&gt; &lt;td class=\"td_d\"&gt; &lt;button class=\"delet\"&gt;删除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_d\"&gt; &lt;input class=\"ck_box\" type=\"checkbox\"&gt; &lt;/td&gt; &lt;td class=\"goods\"&gt; &lt;img src=\"img/2.jpg\" align=\"left\"&gt; &lt;span&gt;三只松鼠-碧根果210g&lt;/span&gt; &lt;/td&gt; &lt;td class=\"td_d price\"&gt;￥38.90&lt;/td&gt; &lt;td class=\"td_d\"&gt; &lt;button class=\"minus\"&gt;-&lt;/button&gt; &lt;input class=\"num\" value=\"1\" type=\"text\"&gt; &lt;button class=\"add\"&gt;+&lt;/button&gt; &lt;/td&gt; &lt;td class=\"td_d smallprice\"&gt;￥38.90&lt;/td&gt; &lt;td class=\"td_d\"&gt; &lt;button class=\"delet\"&gt;删除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_d\"&gt; &lt;input class=\"ck_box\" type=\"checkbox\"&gt; &lt;/td&gt; &lt;td class=\"goods\"&gt; &lt;img src=\"img/2.jpg\" align=\"left\"&gt; &lt;span&gt;三只松鼠-碧根果210g&lt;/span&gt; &lt;/td&gt; &lt;td class=\"td_d price\"&gt;￥38.90&lt;/td&gt; &lt;td class=\"td_d\"&gt; &lt;button class=\"minus\"&gt;-&lt;/button&gt; &lt;input class=\"num\" value=\"1\" type=\"text\"&gt; &lt;button class=\"add\"&gt;+&lt;/button&gt; &lt;/td&gt; &lt;td class=\"td_d smallprice\"&gt;￥38.90&lt;/td&gt; &lt;td class=\"td_d\"&gt; &lt;button class=\"delet\"&gt;删除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_d\"&gt; &lt;input class=\"ck_box\" type=\"checkbox\"&gt; &lt;/td&gt; &lt;td class=\"goods\"&gt; &lt;img src=\"img/2.jpg\" align=\"left\"&gt; &lt;span&gt;三只松鼠-碧根果210g&lt;/span&gt; &lt;/td&gt; &lt;td class=\"td_d price\"&gt;￥38.90&lt;/td&gt; &lt;td class=\"td_d\"&gt; &lt;button class=\"minus\"&gt;-&lt;/button&gt; &lt;input class=\"num\" value=\"1\" type=\"text\"&gt; &lt;button class=\"add\"&gt;+&lt;/button&gt; &lt;/td&gt; &lt;td class=\"td_d smallprice\"&gt;￥38.90&lt;/td&gt; &lt;td class=\"td_d\"&gt; &lt;button class=\"delet\"&gt;删除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_d\"&gt; &lt;input class=\"ck_box\" type=\"checkbox\"&gt; &lt;/td&gt; &lt;td class=\"goods\"&gt; &lt;img src=\"img/2.jpg\" align=\"left\"&gt; &lt;span&gt;三只松鼠-碧根果210g&lt;/span&gt; &lt;/td&gt; &lt;td class=\"td_d price\"&gt;￥38.90&lt;/td&gt; &lt;td class=\"td_d\"&gt; &lt;button class=\"minus\"&gt;-&lt;/button&gt; &lt;input class=\"num\" value=\"1\" type=\"text\"&gt; &lt;button class=\"add\"&gt;+&lt;/button&gt; &lt;/td&gt; &lt;td class=\"td_d smallprice\"&gt;￥38.90&lt;/td&gt; &lt;td class=\"td_d\"&gt; &lt;button class=\"delet\"&gt;删除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;总计&lt;/td&gt; &lt;td colspan=\"5\" class=\"totalPrice\"&gt;￥0.00&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; Style:123456789101112131415161718192021222324252627282930313233343536373839404142table { border-collapse: collapse; } table td { vertical-align: middle; text-align: center; } thead { border: 1px solid black; } thead&gt;tr&gt;th { border: 1px solid black; padding: 5px 20px; } tbody&gt;tr&gt;td { border: 1px solid black; padding: 5px 20px; } input[class=\"num\"] { width: 24px; text-align: center; } td[class=\"goods\"]&gt;img { width: 70px; } td[class=\"goods\"]&gt;span { vertical-align: middle; display: inline-block; transform: translate(5px, 29px) } tfoot td { border: 1px solid black; font-weight: 700 } JavaScript:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//首先实现全选和单选功能 //全选功能首先要判断是否具有checked属性；在jquery中设置或返回被选择元素属性有两种方法attr()和prop(); //需要注意的是attr()并不能用来检测checked是否被选中，他会返回undefined值，即并不能使用attr()方法获取checked属性；那么这里只能用prop()属性获取checked属性，但是注意，所返回的并不是checked/null,而true/false，所以在判断/设置单选框是否被选中时也需要用true/false； $(\".all_ck\").click(function () { //判断是否选中 if ($(this).prop(\"checked\")) { //true $(\".ck_box\").prop({ //隐式迭代 链式操作 checked: true }).parents(\"tr\").css(\"backgroundColor\", \"grey\"); } else { $(\".ck_box\").prop({ //隐式迭代 链式操作 checked: false }).parents(\"tr\").css(\"backgroundColor\", \"\"); } }); //单选 var trueArr = [] $(\".ck_box\").click(function () { var flag = $(this).prop(\"checked\") var CL = $(\".ck_box\").length;//主要是要判断列表长度和被选中的单选框长度是否相等，如果相等就表示全选了 var CH = $(\".ck_box:checked\").length if (CL == CH) { $(\".all_ck\").prop(\"checked\", true) } else { $(\".all_ck\").prop(\"checked\", false) } totalPrice(); }) //三、数量事件：加减按钮的事件和输入数量的事件 //1.加减事件和js的一样，只是这里添加了输入数量的事件，注意需要判读输入的值必须是数字不能是字符。可以用失焦blur()方法实现，也可以用按键事件，这里使用了keypress()和keyup();(按下、抬起事件) //注意：获取输入框value值使用的是val()方法 //数量 $(\".minus\").each(function () { $(this).click(function () { var number = $(this).siblings(\".num\").val(); var price = $(this).parent().siblings(\".price\").html().slice(1) if (number &gt;= 1) { number--; } else { number = 0 } $(this).siblings(\".num\").val(number &lt; 1 &amp;&amp; number &gt;= 0 ? 0 : number); $(this).parent().siblings(\".smallprice\").html(\"￥\" + (price * number).toFixed(2)) totalPrice(); }) }); $(\".add\").each(function () { $(this).click(function () { var number = $(this).siblings(\".num\").val(); var price = $(this).parent().siblings(\".price\").html().slice(1) number++; $(this).siblings(\".num\").val(number); $(this).parent().siblings(\".smallprice\").html(\"￥\" + (price * number).toFixed(2)) totalPrice() }) }); //总计 function totalPrice() { var totalPrice = 0 var a = 0 //总计等于每个被勾选的小计加起来的和 $(\".ck_box\").each(function () { if (this.checked == true) { a = $(this).parent().next().next().next().next().html().slice(1) totalPrice += Number(a) } }) $(\".totalPrice\").html(\"￥\" + totalPrice.toFixed(2)) } //删除 $(\".delet\").click(function () { $(this).parent().parent().remove() })","link":"/2019/09/01/购物车功能（jquery,实现单选，全选，小计，总计，删除）/"},{"title":"Vue 面试题，内含详细讲解","text":"一.《 运算符、运算符优先级》涉及面试题： NaN 是什么？有什么特别之处？解析：在javascript中是一种全局对象的属性，表示这个值不是数字，在js中可以将number对象的值设置为NaN 一般就是表示这个值不是数字；NaN 与其他数值进行比较的结果总是不相等的，包括它自身在内；isNaN可以检测一个值是不是数字。 12345&lt;script type=&quot;text/javascript&quot;&gt; var a=&quot;一&quot;; var b=parseInt(a); alert(b);//汉字转换成int类型是NaN //常在js中用isNaN()来判断这个值是不是数字 == 与 === 有什么区别？解析：==：运算符称作相等，用来检测两个操作数是否相等，这里的相等定义的非常宽松，可以允许进行类型转换===：用来检测两个操作数是否严格相等，不可自动进行类型转换；1、对于string,number等基础类型，==和===是有区别的不同类型间比较，==之比较“转化成同一类型后的值”看“值”是否相等，===如果类型不同，其结果就是不等同类型比较，直接进行“值”比较，两者结果一样2、对于Array,Object等高级类型，==和===是没有区别的3、基础类型与高级类型，==和===是有区别的对于==，将高级转化为基础类型，进行“值”比较，因为类型不同，===结果为false console.log(1+”2”) 和 console.log(1-“2”) 的打印结果？解析：前者会输出12，因为前者会将1转换为字符串类型与2进行拼接；后者会输出-1，后者会将2转换为数值类型进行运算。 为什么 console.log(0.2+0.1==0.3) 输出 false ？解析：因为0.2+0.1是采用二进制进行计算的，输出结果是不等于0.3的所以输出false 请用三元运算符（问号冒号表达式）改写以下代码：if(a &gt; 10) { b = a }else { b = a - 2 }解析：a&gt;10?b=a:b=a-2 以下代码输出的结果是？var a = 1;a+++a;//3typeof a+2;//number解析：3number；a++和++a的区别在于a++是后置运算，意思就是先取值在运算，++a恰好相反，是前置运算，先运算再取值 以下代码输出什么？var d = a = 3, b = 4console.log(d)解析：var d = a = 3的声明过程：a = 3;var d = a; 以下代码输出什么？var d = (a = 3, b = 4)console.log(d) 以下代码输出结果是？为什么？var a = 1, b = 2, c = 3;var val = typeof a + b || c &gt;0console.log(val)var d = 5;var data = d ==5 &amp;&amp; console.log(“bb”)console.log(data)var data2 = d = 0 || console.log(“haha”)console.log(data2)var x = !!”Hello” + (!”world”, !!”from here!!”);console.log(x) 以下代码输出结果是？为什么？var a = 1;var b = 3;console.log( a+++b ); 以下代码输出的结果是？为什么？console.log(1+1);console.log(“2”+”4”);console.log(2+”4”);console.log(+”4”); 《 变量、值、数据类型、数据类型转换》涉及面试题： JavaScript 定义了几种数据类型？哪些是原始类型？哪些是复杂类型？null 是对象吗？解析：js一共定义了两大类数据类型，原始类型和引用类型；原始类型：numberstringbooleanundefinednull引用类型：object类型Array类型Date类型Function类型RegExp类型虽然typeof null 返回的值是object，但是null不是对象，而是一种基本数据类型基本数据类型存储在栈内存，存储的是值‘复杂数据类型的值存储在堆内存，地址（指向真实数据）存储在栈内存，当我们把对象赋值给另外一个变量的时候，赋值的是地址，指向同一块内存，当一个对象改变时，另外一个也会变化 对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？解析：对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）；首先，函数传参是传递对象指针的副本到函数内部修改参数的属性这步，我相信大家都知道，当前p1的值也被修改了但是当我们重新为了person分配了一个对象时就出现了最后person拥有了一个新的地址（指针），也就和p1没有任何关系了，导致了最终两个变量的值是不相同的 怎样判断“值”属于哪种类型？typeof 是否能正确判断类型？instanceof 呢？解析：typeof只能用于判断原始类型；typeof (null)会返回Objectinstanceof 有什么作用？内部逻辑是如何实现的？instanceOf判断一个对象是不是某个类型的实例;通过原型链的方式查找。 null，undefined 的区别？解析：null表示没有对象，即该处不应该有值1） 作为函数的参数，表示该函数的参数不是对象2） 作为对象原型链的终点undefined表示缺少值，即此处应该有值，但没有定义1）定义了形参，没有传实参，显示undefined2）对象属性名不存在时，显示undefined3）函数没有写返回值，即没有写return，拿到的是undefined4）写了return，但没有赋值，拿到的是undefinednull和undefined转换成number数据类型null 默认转成 0undefined 默认转成 NaN 说一下 JS 中类型转换的规则？解析：显示转换：转换为数值类型：Number(mix)、parseInt(string,radix)、parseFloat(string)转换为字符串类型：toString(radix)、String(mix)转换为布尔类型：Boolean(mix)隐式转换： 以下代码的输出？为什么？ console.log(a); var a = 1; console.log(b); 以下代码输出什么？ var a = typeof 3+4 console.log(a) 以下代码输出什么？ var a = typeof typeof 4+4 console.log(a)《流程控制语句》涉及面试题： break 与 continue 有什么区别？解析：1.break 语句可用于跳出循环。2.break所在的循环体已经结束。3.continue 语句中断循环中的迭代，如果出现了指定的条件，然后继续循环中的下一个迭代。4.continue所在的循环体并没有结束。 12345678910111213for (i=0;i&lt;5;i++){ if (i==3) break; x=x + &quot;The number is &quot; + i + &quot;&lt;br&gt;&quot;;}// 只输出 0 ， 1 ， 2 ， 到3就跳出循环了---for (i=0;i&lt;=5;i++){ if (i==3) continue; x=x + &quot;The number is &quot; + i + &quot;&lt;br&gt;&quot;;}// 不输出3，因为continue跳过了，直接进入下一个迭代 switch…case 语句中的 break 有什么作用？ 12345678910111213141516171819202122switch (new Date().getDay()) { case 0: day = &quot;星期天&quot;; break; case 1: day = &quot;星期一&quot;; break; case 2: day = &quot;星期二&quot;; break; case 3: day = &quot;星期三&quot;; break; case 4: day = &quot;星期四&quot;; break; case 5: day = &quot;星期五&quot;; break; case 6: day = &quot;星期六&quot;;} 如果 JavaScript 遇到 break 关键词，它会跳出 switch 代码块。此举将停止代码块中更多代码的执行以及 case 测试。如果找到匹配，并完成任务，则随机中断执行（break）。无需更多测试。break 能够节省大量执行时间，因为它会“忽略” switch 代码块中的其他代码的执行。不必中断 switch 代码块中的最后一个 case。代码块在此处会自然结束。 for…of、 for…in 和 forEach、map 的区别？解析：1.for…in 以原始插入顺序遍历对象的可枚举属性，对于每个不同的属性，语句都会被执行。写法：for(var variable in obj)。例子： var obj={a:1,c:3,b:2},for(var item in obj){console.log(“obj.”+item+”=”+obj[item])}，打印结果：obj.a=1，obj.c=3，obj.b=2。使用注意：for…in不一定返回的是按一定顺序的索引，只能获取键名，不能直接获取键值，因此不应该被用来迭代一个下表很重要的数组，适合用于遍历对象属性。 2.for…of es6提供的新语法，可以用来替代数组原始的forEach方法,使用范围包括数组、字符串、类似数组的对象（arguments对象、DOM NodeList对象）。写法：for(let variable of obj)，例子：const arr=[‘red’,’green’,’blue’];for(letv of arr){console.log(v); // red green blue}使用注意：for…of循环获取的是键值，如果要获取索引，可以通过数组实例的entries（键值对的索引）方法和keys（键名的索引）方法，数组的遍历器接口只返回具有数字索引的属相，因此不适合用来遍历对象。 3.数组的forEach方法 es5数组对象自带的方法，调用数组中的每个元素，并将每个元素传给回调函数使用。写法：[].forEach(function(value,index,array){});使用注意：在第一次调用回调函数之前，数组中的元素都已经是确定的。 4.map()方法返回一个新数组，这个数组中的元素是原始数组中的每个元素调用回调函数之后返回的结果，按原始数组元素依次处理数组中的元素，map方法不会改变原始数组。写法：array.map(function(currentValue,index,arr), thisValue)，值得注意的是要记得为每个元素指定一个独一无二的key 写出如下知识点的代码范例： ① if…else 的用法； ② switch…case 的用法； ③ while 的用法； ④ do…while 的用法； ⑤ for 遍历数组的用法； ⑥ for…in 遍历对象的用法； ⑦ break 和 continue 的用法。 以下代码输出什么？ var a = 2 if(a = 1) { console.log(“a 等于 1”) }else { console.log(“a 不等于 1”) }《JS 函数——养成函数思维》涉及面试题： 写一个函数，返回参数的平方和？ 12345678910111213141516 function sumOfSquares() { // 补全 var result=0; for (var i in arguments) { if (typeof arguments[i] !== &apos;number&apos;) { return &apos;you enter a wrong number&apos;; } else { result += arguments[i] * arguments[i]; }}return result; } var result = sumOfSquares(2, 3, 4) var result2 = sumOfSquares(1, 3) console.log(result) // 29 console.log(result2) // 10 如下代码的输出？为什么？ sayName(“world”); sayAge(10); function sayName(name) { console.log(“hello “, name); } var sayAge = function(age) { console.log(age); };解析：函数声明具有函数声明提前的特点函数表达式不会声明提前 如下代码的输出？为什么？ var x = 10; bar() function bar() { var x = 30; function foo() { console.log(x) } foo(); }解析：30 如下代码的输出？为什么？ var x = 10 bar() function foo() { console.log(x)//10 } function bar() { var x = 30 foo() }解析： 声明前置globalContext = {AO:{ x:10, foo:function(){}, bar:function(){}},Scope:null}foo.[[scope]] = globalContext.AObar.[[scope]] = globalContext.AO 调用 barbarContext = {AO:{ x:30}Scope:bar.[[scope]] = globalContext.AO} 调用 foofooContext = {AO:{}Scope:foo.[[scope]] = globalContext.AO} 如下代码的输出？为什么？ var a = 1 function fn1() { function fn3() {function fn2() { console.log(a) } fn2()//undefined var a = 4 } var a = 2 return fn3 } var fn = fn1() fn() // ？解析：undefined 如下代码的输出？为什么？ var a = 1 function fn1() { function fn2() { console.log(a) } function fn3() { var a = 4 fn2() } var a = 2 return fn3 } var fn = fn1() fn() // ？ 如下代码的输出？为什么？ var a = 1 function fn1() { function fn3() { var a = 4 fn2() } var a = 2 return fn3 } function fn2() { console.log(a) } var fn = fn1() fn() // ？ 如下代码的输出？为什么？ var a = 1 var c = {name: “oli”, age: 2} function f1(n) { ++n } function f2(obj) { ++obj.age } f1(a) f2(c) f1(c.age) console.log(a) console.log(c) 如下代码的输出？为什么？ var obj1 = {a:1, b:2}; var obj2 = {a:1, b:2}; console.log(obj1 == obj2); console.log(obj1 = obj2); console.log(obj1 == obj2);《JS 数组——让数据排排坐》涉及面试题： 写一个函数 squireArr，其参数是一个数组，作用是把数组中的每一项变为原值的平方。 var arr = [3, 4, 6] function squireArr(arr) { // 补全 return arr.forEach(function(e,i,array) { return array[i] = e * e }) }) } } squireArr(arr) console.log(arr) // [9, 16, 36] 写一个函数 squireArr，其参数是一个数组，返回一个新的数组，新数组中的每一项是原数组对应值的平方，原数组不变。 var arr = [3, 4, 6] function squireArr(arr) { // 补全 return arr.map(function(ele) { return ele * ele }) } } squireArr(arr) console.log(arr) // [9, 16, 36] 遍历 company 对象，输出里面每一项的值。 var company = { name: “qdywxs”, age: 3, sex: “男” }解析：for(var key in company){console.log(company[key])} 遍历数组，打印数组里的每一项的平方。 var arr = [3, 4, 5]解析：123456var arr = [3, 4, 5]var sum=0for(var key in arr){ sum+=arr[key]*arr[key]}console.log(sum) 《JS 对象——理解对象》涉及面试题： 介绍 JS 有哪些内置对象？解析：Array对象、Date对象、正则表达式对象、string对象、Global对象等 以下代码输出什么？ var name = “sex” var company = { name: “qdywxs”, age: 3, sex: “男” } console.log(company[name]) 以下代码输出什么？ var name = “sex” var company = { name: “qdywxs”, age: 3, sex: “男” } console.log(company.name)《了解 DOM——与网页交互》《JS 事件——异步编码》《JS 函数：嵌套函数、作用域和闭包》涉及面试题： 闭包是什么？闭包的作用是什么？闭包有哪些使用场景？ 使用递归完成 1 到 100 的累加？ 谈谈垃圾回收机制的方式及内存管理？ 谈谈你对 JS 执行上下文栈和作用域链的理解？ 如下代码输出多少？如果想输出 3，那如何改造代码？ var fnArr = []; for(var i=0; i&lt;10; i++) { fnArr[i] = function() { return i }; } console.log(fnArr3) 封装一个 Car 对象。 var Car = (function() { var speed = 0; // 补充 return { setSpeed: setSpeed, getSpeed: getSpeed, speedUp: speedUp, speedDown: speedDown } })() Car.setSpeed(30) Car.getSpeed() // 30 Car.speedUp() Car.getSpeed() // 31 Car.speedDown() Car.getSpeed() // 30 如下代码输出多少？如何连续输出 0, 1, 2, 3, 4？ for(var i=0; i&lt;5; i++) { setTimeout(function() { console.log(&quot;delayer:&quot; + i) }, 0) } 如下代码输出多少？ function makeCounter() { var count = 0 return function() { return count++ }; } var counter = makeCounter() var counter2 = makeCounter(); console.log(counter()) // 0 console.log(counter()) // 1 console.log(counter2()) // ？ console.log(counter2()) // ？ 《JS 数组：① ES3 数组方法》[编号：js_12]涉及面试题： 数组的哪些 API 会改变原数组？解析：改变数组：var arr = []arr.splice()arr.reverse()arr.fill()arr.copyWithin()arr.sort()arr.push()arr.pop()arr.unshift()arr.shift()不改变数组：var arr = []arr.slice()arr.map()arr.forEach()arr.every()arr.some()arr.filter()arr.reduce()arr.entries()arr.find()arr.concat(‘1’,[‘2’,’3’]) //[1,2,3] 写一个函数，操作数组，返回一个新数组，新数组中只包含正数。 function filterPositive(arr) { // 补全 } var arr = [3, -1, 2, true] filterPositive(arr) console.log(filterPositive(arr)) // [3, 2] 补全代码，实现数组按姓名、年纪、任意字段排序。 var users = [ {name: “John”, age: 20, company: “Baidu”}, {name: “Pete”, age: 18, company: “Alibaba”}, {name: “Ann”, age: 19, company: “Tecent”} ] users.sort(byField(“age”)) users.sort(byField(“company”)) 用 splice 函数分别实现 push、pop、shift、unshift 方法。如: function push(arr, value) { arr.splice(arr.length, 0, value) return arr.length } var arr = [3, 4, 5] arr.push(10) // arr 变成 [3, 4, 5, 10]，返回 4。《JS 数组：② ES5 数组方法》涉及面试题： for…of、 for…in 和 forEach、map 的区别？ 数组的哪些 API 会改变原数组？ 如何消除一个数组里面重复的元素？ 判断一个变量是否是数组，有哪些办法？ [“1”, “2”, “3”].map(parseInt) 答案是多少？ 取数组的最大值（ES5、ES6）？ 实现一个 reduce 函数，作用和原生的 reduce 类似下面的例子。Ex： var sum = reduce([1, 2, 3], function(memo, num) {return memo + num;}, 0); =&gt; 6 怎样用原生 JS 将一个多维数组拍平？ var array = [1, [2], [3, [4, [5]]]] function flat(arr) { // 补全 } console.log(flat(array)) // [1, 2, 3, 4, 5]《面向对象编程：对象构造函数》涉及面试题： new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？解析：1.创建一个新对象。2.这个新对象会被执行[[原型]]连接。3.将构造函数的作用域赋值给新对象，即this指向这个新对象.4.如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。字面量创建对象，不会调用 Object构造函数, 简洁且性能更好;new Object() 方式创建对象本质上是方法调用，涉及到在proto链中遍历该方法，当找到该方法后，又会生产方法调用必须的 堆栈信息，方法调用结束后，还要释放该堆栈，性能不如字面量的方式。 Object.create 有什么作用？ JavaScript 有哪些方法定义对象？解析：1.使用系统的new Object()方式定义对象123456789101112131415161718//使用系统的new Object()方式定义对象var person=new Object();console.log(typeof person);//objectconsole.log(person);//{}//给对象设置属性和方法，使用.操作符person.name=&apos;lucky&apos;;person.age=27;person.sex=&apos;女&apos;;person.play=function(){ console.log(&quot;我会打篮球&quot;)}console.log(person)//操作对象//输出属性console.log(person.name);//luckyconsole.log(person.play);//输出为函数//调用函数person.play() 2、使用对象字面量定义对象( 即使用{}语法糖结构定义对象 )1234567891011121314var person={ name:&quot;lucky&quot;, age:27, sex:&quot;女&quot;, play:function(){ console.log(&quot;我会打篮球&quot;) }}console.log(typeof person)console.log(person)//输出属性console.log(person.name)console.log(person.play)person.play() 3、使用自定义的构造函数声明多个类型特点一致的对象1234567891011121314151617function Person(name,age,sex,play){ //使用this关键字指向的就是自身 console.log(this) this.name=name; this.age=age; this.sex=sex; this.play=play;}Person()//console.log(this);会输出window//new关键字，专门用于实例化对象var p1=new Person(&quot;lucky&quot;,&quot;27&quot;,&quot;女&quot;,function(){ console.log(&quot;我会飞&quot;)})var p2=new Person(&quot;marry&quot;,&quot;27&quot;,&quot;女&quot;,function(){ console.log(&quot;我会飞&quot;)})//p1、p2都是同一个构造函数实例化生成的，具有相同的特点 如下代码中？new 一个函数本质上做了什么？ function Modal(msg) { this.msg = msg } var modal = new Modal()《面向对象编程：使用原型》涉及面试题： JS 原型是什么？如何理解原型链？解析：每个函数都有一个prototype(原型)属性这个属性都有一个指针，指向一个对象这个对象包含由特定类型所有实例共享的属性和方法使用原型的好处是可以让所有对象实例共享它包含的方法和属性ECMAScript中只支持实现继承，而且是通过原型链的方式来实现的。所以原型链是JavaScript实现继承的一种重要方式。1.每个函数对象都有一个 prototype 属性，这个属性就是函数的原型对象。2.原型链是JavaScript实现继承的重要方式，原型链的形成是真正是靠proto 而非prototype。 JS 如何实现继承？解析：js中实现继承的方式主要是通过原型链完成的。 实现一个函数 clone 可以对 JavaScript 中的五种主要数据类型（Number、string、Object、Array、 Boolean）进行复制？ 对 String 做扩展，实现如下方式获取字符串中频率最高的字符： var str = “ahbbccdeddddfg”; var ch = str.getMostOften(); console.log(ch); // d，因为 d 出现了 5 次 有如下代码，代码中并未添加 toString 方法，这个方法是哪里来的？画出原型链图进行解释： function People() { } var p = new People() p.toString() 有如下代码，解释 Person、 prototype、proto、p、constructor 之间的关联： function Person(name) { this.name = name; } Person.prototype.sayName = function() { console.log(“My name is :” + this.name); } var p = new Person(“Oli”) p.sayName(); 下面两种写法有什么区别？ // 方法一： function People(name, sex) { this.name = name; this.sex = sex; this.printName = function() { console.log(this.name); } } var p1 = new People(“Oli”, 2) // 方法二： function Person(name, sex) { this.name = name; this.sex = sex; } Person.prototype.printName = function() { console.log(this.name); } var p1 = new Person(“Aman”, 2); 补全代码，实现继承： function Person(name, sex){ // 补全 }; Person.prototype.getName = function() { // 补全 }; function Male(name, sex, age) { // 补全 }; // 补全 Male.prototype.getAge = function() { // 补全 }; var catcher = new Male(“Oli”, “男”, 2); catcher.getName(); 如下代码中 call 的作用是什么？ function Person(name, sex) { this.name = name; this.sex = sex; } function Male(name, sex, age) { Person.call(this, name, sex); // 这里的 call 有什么作用？ this.age = age; }","link":"/2020/02/28/面试题-JS/"}],"tags":[{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"Html","slug":"Html","link":"/tags/Html/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Axios","slug":"Axios","link":"/tags/Axios/"},{"name":"Jquery","slug":"Jquery","link":"/tags/Jquery/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"个人简历","slug":"个人简历","link":"/tags/个人简历/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"}],"categories":[{"name":"前端开发","slug":"前端开发","link":"/categories/前端开发/"},{"name":"个人简历","slug":"个人简历","link":"/categories/个人简历/"}]}